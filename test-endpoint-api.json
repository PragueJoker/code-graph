{
  "projectName": "code-graph-engine",
  "absoluteFilePath": "/Users/joker/code-graph/code-graph-engine/src/main/java/com/poseidon/codegraph/engine/adapter/controller/CodeGraphController.java",
  "projectFilePath": "code-graph-engine/src/main/java/com/poseidon/codegraph/engine/adapter/controller/CodeGraphController.java",
  "gitRepoUrl": "https://github.com/example/code-graph",
  "gitBranch": "main",
  "classpathEntries": [
    "/Users/joker/code-graph/code-graph-engine/target/classes",
    "/Users/joker/.m2/repository/org/springframework/boot/spring-boot-starter-web/3.2.0/spring-boot-starter-web-3.2.0.jar",
    "/Users/joker/.m2/repository/org/springframework/spring-web/6.1.1/spring-web-6.1.1.jar",
    "/Users/joker/.m2/repository/org/springframework/spring-webmvc/6.1.1/spring-webmvc-6.1.1.jar"
  ],
  "sourcepathEntries": [
    "/Users/joker/code-graph/code-graph-engine/src/main/java"
  ]
}


我发现个问题   @Override

public Mono<io.vavr.collection.List<SphinxMember>> fetchOrgMemberProfilesByLdapAndTenantId(Collection<String> userNames, Long tenantId) {

return loadBalancedWebClientBuilder.build()

.post()

.uri(ldapProfileNoToken)

.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)

.header(Constants.X_TENANT_ID, String.valueOf(tenantId))

.body(BodyInserters.fromObject(userNames))

.retrieve()

.onStatus(HttpStatus::is4xxClientError, upstream4xxException())

.onStatus(HttpStatus::is5xxServerError, upstream5xxException())

.bodyToMono(new ParameterizedTypeReference<Response<List<SphinxMember>>>() {

})

.doOnNext(response -> {

System.out.println("Sphinx服务响应: " + (response != null ? response.toString() : "null"));

if (response != null && response.getData() != null) {

System.out.println("返回数据数量: " + response.getData().size());

response.getData().forEach(member ->

System.out.println("SphinxMember: " + (member != null ? member.toString() : "null")));

}

})

.map(Response::getData)

.map(io.vavr.collection.List::ofAll);

@Override

public Mono<List<SphinxMember>> fetchProfileByLdap(List<String> ldaps) {

return loadBalancedWebClientBuilder.build()

.post()

.uri(fetchLdapProfilesUrl)

.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)

.body(BodyInserters.fromObject(ldaps))

.retrieve()

.onStatus(HttpStatus::is4xxClientError, GatewayErrorHandler.upstream4xxException())

.onStatus(HttpStatus::is5xxServerError, GatewayErrorHandler.upstream5xxException())

.bodyToMono(new ParameterizedTypeReference<SphinxResp<List<SphinxMember>>>() {

})

.filter(resp -> resp.getCode() == 0)

.map(SphinxResp::getData)

.defaultIfEmpty(Collections.emptyList());

}这两个方法用的path 是一样的，然后就把第一个方法的functiontoendpotin 关系给干掉了不知道在什么地方 给我找一下





原因就在“端点 ID 只由 path 决定 + 去重逻辑”这两段组合上，所以 path 一样会把 `FUNCTION_TO_ENDPOINT` 关系“干掉”（准确说是只保留一个 endpoint 实例，从而只建一条关系）。

关键位置：

- 端点 ID 生成只包含 `direction/type/path`，没有函数信息，path 一样会生成同一个 endpoint id  
  `src/main/java/com/xiaoju/cooper/code/graph/domain/parser/endpoint/epr/engine/SimpleEprEngine.java`（`generateEndpointId`）

- 建关系前先按 `endpoint.getId()` 去重，只保留第一个 endpoint  
  `src/main/java/com/xiaoju/cooper/code/graph/domain/parser/processor/EndpointProcessor.java`（`onTraversalComplete` 里 `uniqueEndpoints.putIfAbsent(endpoint.getId(), endpoint)`）

- 持久化端点也按 ID 去重并跳过已存在  
  `src/main/java/com/xiaoju/cooper/code/graph/domain/service/processor/AbstractChangeProcessor.java`（`saveEndpointsWithCheck`）

结果：两个方法命中了同一个 path ⇒ endpoint id 相同 ⇒ 只保留一个 endpoint ⇒ `findFunctionByEndpoint` 只会给这个 endpoint 绑定一个函数 ⇒ 只生成一条 `FUNCTION_TO_ENDPOINT` 关系，另一个函数的关系被“吞掉”。

如果你希望一个 endpoint 节点能关联多个函数，有两种典型修法：

1) 保持 endpoint 节点唯一（id 还是基于 path），但在关系构建阶段不要对 endpoints 去重，或者按 path 扫描所有函数并为同一 endpoint 建多条关系。  
2) 或者把 `functionId`/`qualifiedName` 纳入 endpoint id，让每个函数生成独立 endpoint 节点（但这样会产生多个“同路径” endpoint 节点）。

你希望最终图里是“一个 endpoint 对多函数”还是“多个 endpoint 节点”？我可以按你的目标给出具体改法。
